# üìñ Documentaci√≥n del Int√©rprete y REPL de Zisk üêç

## üöÄ 1. Introducci√≥n

Zisk es un lenguaje de programaci√≥n interpretado, y este proyecto implementa un int√©rprete completo junto con un REPL (Read-Eval-Print Loop) üîÑ para interactuar con √©l. El sistema est√° construido en Python 3 üêç y consta de varios componentes clave que trabajan juntos para analizar, (opcionalmente) optimizar ‚ú®, (opcionalmente) compilar a Python üìú, y ejecutar c√≥digo Zisk ‚ñ∂Ô∏è.

**üéØ Esencialmente, el REPL de Zisk hace lo siguiente:**

1.  **‚úçÔ∏è Lee** el c√≥digo Zisk introducido por el usuario (l√≠nea por l√≠nea o bloques multil√≠nea).
2.  **üß† Analiza (Eval√∫a)** este c√≥digo:
    *   **üîç `ZiskLexer`:** Convierte el texto del c√≥digo en una secuencia de "tokens" (palabras clave, identificadores, n√∫meros, operadores, etc.).
    *   **üå≥ `ZiskParser`:** Toma estos tokens y construye un √Årbol de Sintaxis Abstracta (AST), que es una representaci√≥n estructurada del c√≥digo.
    *   **‚ú® `ZiskOptimizer`:** (Opcional) Realiza transformaciones simples en el AST para mejorar su eficiencia (ej. plegado de constantes).
    *   **‚öôÔ∏è Motor de Ejecuci√≥n** (parte de `ZiskREPL.execute`): Recorre el AST y ejecuta las instrucciones, gestionando variables, √°mbitos, llamadas a funciones, control de flujo, y operaciones.
    *   **üè∑Ô∏è `ZiskTypeSystem`:** Se utiliza durante la ejecuci√≥n (y potencialmente en el parsing si se expande) para verificar la compatibilidad de tipos y realizar inferencias.
3.  **üìÑ Imprime** el resultado de la evaluaci√≥n (si lo hay) en la consola.
4.  **üîÑ Repite (Loop)** el proceso, esperando la siguiente entrada del usuario.

Adem√°s de la interpretaci√≥n directa del AST, el sistema tambi√©n incluye un **üèóÔ∏è `ZiskCompiler`** que puede traducir el AST de Zisk a c√≥digo Python ejecutable, permitiendo potencialmente la "compilaci√≥n" de scripts Zisk a Python. El REPL tambi√©n maneja comandos especiales (ej. `:cargar`, `:ayuda`) para mejorar la interactividad.

## üß© 2. Componentes del Sistema

### ‚ö†Ô∏è 2.1. Excepciones Personalizadas

Zisk define sus propias excepciones para un manejo de errores m√°s espec√≠fico y claro.

*   **`ZiskError(Exception)`** ‚ùå: Clase base para todos los errores de Zisk. Almacena un mensaje, l√≠nea y columna donde ocurri√≥ el error.
    *   **`ZiskTypeError(ZiskError)`** üö´: Para errores relacionados con tipos de datos incompatibles.
    *   **`ZiskRuntimeError(ZiskError)`** üí•: Errores generales que ocurren durante la ejecuci√≥n del c√≥digo Zisk.
    *   **`ZiskAttributeError(ZiskRuntimeError)`** üîç‚ùì: Para accesos a atributos/propiedades inexistentes.
    *   **`ZiskIndexError(ZiskRuntimeError)`** üî¢‚ùì: Para √≠ndices fuera de rango en listas o cadenas.
    *   **`ZiskKeyError(ZiskRuntimeError)`** üîë‚ùì: Para claves no encontradas en objetos/diccionarios.
*   **`BreakException(Exception)`** üõë: Usada internamente para implementar la sentencia `break` en bucles.
*   **`ContinueException(Exception)`** ‚Ü™Ô∏è: Usada internamente para implementar la sentencia `continua` en bucles.
*   **`ReturnException(Exception)`** üì§: Usada internamente para implementar la sentencia `retorna` desde funciones/m√©todos. Almacena el valor a retornar.

### üîç 2.2. `ZiskLexer` (Analizador L√©xico)

El lexer es responsable de tomar el c√≥digo fuente de Zisk como una cadena y dividirlo en una secuencia de tokens.

*   **`__init__(self)`**:
    *   Define `self.tokens_spec`: Una lista de tuplas, donde cada tupla contiene el nombre del tipo de token y una expresi√≥n regular para reconocerlo. Las palabras clave est√°n ordenadas por longitud descendente para evitar ambig√ºedades con prefijos.
    *   Precompila todas las expresiones regulares en un solo patr√≥n para eficiencia.
    *   Inicializa contadores de l√≠nea y columna.
*   **`tokenize(self, code: str) -> List[Tuple[str, str, int, int]]`**:
    *   Itera sobre el c√≥digo de entrada, intentando hacer coincidir los patrones de token en la posici√≥n actual.
    *   Ignora comentarios (`COMENTARIO_LINEA`, `COMENTARIO_BLOQUE`) y espacios en blanco (`ESPACIO`).
    *   Si un car√°cter no coincide con ning√∫n token v√°lido (y no es espacio/comentario), se marca como `NO_VALIDO` y lanza un `ZiskError`.
    *   Devuelve una lista de tuplas, donde cada tupla es `(TIPO_TOKEN, VALOR_TOKEN, NUM_LINEA, NUM_COLUMNA)`.

### üå≥ 2.3. `ZiskParser` (Analizador Sint√°ctico)

El parser toma la lista de tokens generada por el lexer y construye un √Årbol de Sintaxis Abstracta (AST). El AST es una representaci√≥n jer√°rquica de la estructura del c√≥digo. Utiliza un enfoque de descenso recursivo.

*   **`__init__(self)`**:
    *   Inicializa la lista de tokens, el √≠ndice del token actual, y una pila de √°mbitos (`self.scopes`) para el an√°lisis sem√°ntico b√°sico (verificar declaraciones de variables).
    *   `self.current_class`: Rastrea si el parser est√° dentro de la definici√≥n de una clase.
*   **M√©todos de gesti√≥n de √°mbito (parser)**: `enter_scope()`, `exit_scope()`, `current_scope()`, `variable_declared_in_current_scope()`, `variable_declared()`.
*   **`parse(self, tokens)`**: Inicia el proceso de parsing.
*   **`parse_programa()`**: Punto de entrada, parsea una secuencia de declaraciones.
*   **`parse_declaracion()`**: Determina si el token actual inicia una funci√≥n, clase, variable, constante, importaci√≥n o una sentencia general.
*   **M√©todos de parsing espec√≠ficos**:
    *   `parse_funcion()`: Parsea `funcion nombre(params): tipo_retorno { cuerpo }`.
    *   `parse_clase()`: Parsea `clase Nombre extiende SuperClase { miembros }`.
    *   `parse_declaracion_miembro_clase()`: Parsea atributos de clase.
    *   `parse_metodo_clase()`: Parsea m√©todos de clase, incluyendo modificadores como `estatico`, `publico`, `privado`.
    *   `parse_declaracion_variable()`: Parsea `var nombre: tipo = valor;`.
    *   `parse_declaracion_constante()`: Parsea `const NOMBRE: tipo = valor;`.
    *   `parse_sentencia()`: Dirige a otros m√©todos de parsing de sentencias (`parse_si()`, `parse_mientras()`, etc.) o expresiones.
    *   **Jerarqu√≠a de Expresiones (`parse_expresion_...`)**: Un conjunto de m√©todos para parsear expresiones respetando la precedencia de operadores (asignaci√≥n, l√≥gicos, comparaci√≥n, adici√≥n, multiplicaci√≥n, unarios, llamada/acceso, primarios).
        *   `parse_expresion_primaria()`: Parsea los elementos m√°s b√°sicos como literales (n√∫meros, cadenas, booleanos, nulo), identificadores, expresiones entre par√©ntesis, `nuevo Clase()`, `este`, `ingresar()`, literales de lista `[]` y objeto `{}`.
    *   `parse_lista_literal()`, `parse_objeto_literal()`.
    *   **Sentencias de Control**: `parse_si()`, `parse_mientras()`, `parse_para()`, `parse_hacer_mientras()`.
    *   **Otras Sentencias**: `parse_mostrar()`, `parse_retorna()`, `parse_break()`, `parse_continua()`, `parse_try_catch()`, `parse_importa()`.
    *   `parse_bloque()`: Parsea un bloque de sentencias encerrado en `{}`. Abre y cierra un nuevo √°mbito.
    *   `parse_bloque_o_sentencia()`: Permite que estructuras como `si` o `mientras` tengan un bloque `{}` o una sola sentencia.
*   **`consume(self, expected_type, expected_value)`**: Avanza al siguiente token, verificando opcionalmente su tipo y/o valor. Lanza un error si no coincide.
*   **`consume_optional_semicolon()`**: Consume un punto y coma si est√° presente.

### üè∑Ô∏è 2.4. `ZiskTypeSystem` (Sistema de Tipos)

Gestiona la informaci√≥n de tipos, realiza comprobaciones y ayuda en la inferencia de tipos.

*   **`__init__(self)`**:
    *   `self.type_map`: Mapea nombres de tipos de Zisk (`entero`, `texto`, etc.) a tipos de Python (`int`, `str`, etc.).
    *   `self.type_annotations`: Almacena anotaciones de tipo para variables.
    *   `self.class_hierarchy`: Almacena la relaci√≥n de herencia entre clases de Zisk.
    *   `self.method_signatures`: Almacena las firmas de los m√©todos (tipos de par√°metros y retorno).
*   **`check_type(self, value, expected_type_zisk, ...)`**: ‚úÖ Verifica si un valor Python es compatible con un tipo Zisk esperado. Considera clases definidas por el usuario.
*   **`infer_type(self, value)`**: ü§î Intenta deducir el tipo Zisk de un valor Python.
*   **`validate_assignment(self, ..., expected_type_zisk, ...)`**: ‚úÖ Valida si un valor puede ser asignado a una variable/par√°metro/retorno con un tipo Zisk esperado.
*   **`add_variable_annotation(...)`, `get_variable_type(...)`**: Gestiona anotaciones de tipo para variables.
*   **`add_class(...)`, `add_method_signature(...)`, `get_method_signature(...)`**: Registra informaci√≥n sobre clases y m√©todos para el an√°lisis de tipos.
*   **`validate_function_call(...)`**: Comprueba si los argumentos de una llamada a funci√≥n coinciden con los tipos esperados de los par√°metros.
*   **`is_subclass_or_same(...)`**: Verifica la relaci√≥n de herencia entre clases Zisk.

### ‚ú® 2.5. `ZiskOptimizer` (Optimizador)

Realiza transformaciones b√°sicas en el AST para mejorar potencialmente el rendimiento o reducir el c√≥digo.

*   **`__init__(self)`**: Habilita/deshabilita optimizaciones espec√≠ficas (`constant_folding`, `dead_code_elimination`).
*   **`optimize(self, ast_node)`**:
    *   Recorre el AST (post-orden).
    *   **Plegado de Constantes**: Si encuentra una operaci√≥n aritm√©tica con operandos literales num√©ricos (ej. `2 + 3`), la reemplaza por el resultado (`('NUMERO', 5)`).
    *   **Eliminaci√≥n de C√≥digo Muerto**:
        *   Si encuentra `si (verdadero) { ... } sino { ... }`, reemplaza toda la estructura `si` por el bloque del `si`.
        *   Si encuentra `si (falso) { ... } sino { ... }`, reemplaza por el bloque `sino` (o nada si no hay `sino`).
        *   Si encuentra `mientras (falso) { ... }`, elimina el bucle.

### üèóÔ∏èüêç 2.6. `ZiskCompiler` (Compilador a Python)

Traduce el AST de Zisk a c√≥digo fuente de Python.

*   **`__init__(self)`**: Inicializa el nivel de indentaci√≥n y el nombre de la clase actual (si aplica). `self.imported_modules` para evitar importaciones duplicadas en el c√≥digo Python generado.
*   **`_indent(self)`**: Genera la cadena de indentaci√≥n actual.
*   **`compile(self, ast_node)`**:
    *   M√©todo principal que recibe un nodo del AST y devuelve su representaci√≥n como c√≥digo Python.
    *   Utiliza una serie de `if/elif` para manejar cada tipo de nodo del AST (`PROGRAMA`, `FUNCION`, `CLASE`, `ASIGNACION`, `OPERACION_ARITMETICA`, etc.).
    *   Para cada nodo, genera la sintaxis Python equivalente:
        *   `funcion` Zisk -> `def` Python.
        *   `clase` Zisk -> `class` Python (incluyendo herencia y `__init__` para campos de instancia).
        *   M√©todos Zisk -> M√©todos Python (con `@staticmethod` si es necesario).
        *   `var`, `const` Zisk -> Asignaciones Python.
        *   `importa` Zisk -> `import` Python.
        *   Estructuras de control (`si`, `mientras`, `para`, `hacer_mientras`, `try-catch`) -> Equivalentes en Python.
        *   Operaciones Zisk (`&&`, `||`) -> `and`, `or` Python.
        *   Llamadas a funciones/m√©todos/constructores Zisk -> Llamadas Python.
        *   Literales Zisk (`nulo`) -> Literales Python (`None`).
    *   Maneja la indentaci√≥n del c√≥digo Python generado.
    *   Las llamadas a funciones "nativas" de Zisk como `mostrar` o `ingresar` se traducen a `print` e `input` de Python respectivamente.

### üíª‚ñ∂Ô∏è 2.7. `ZiskREPL` (REPL y Motor de Ejecuci√≥n)

Es el coraz√≥n interactivo del int√©rprete. Gestiona el ciclo de lectura, evaluaci√≥n e impresi√≥n, y tambi√©n contiene la l√≥gica para ejecutar directamente el AST.

*   **`__init__(self, type_system)`**:
    *   Instancia `ZiskLexer`, `ZiskParser`, `ZiskOptimizer`, `ZiskCompiler`.
    *   Usa una instancia de `ZiskTypeSystem`.
    *   **Estado del REPL (Runtime)**:
        *   `self.scopes`: Pila de √°mbitos para almacenar variables en tiempo de ejecuci√≥n. El primer elemento es el √°mbito global.
        *   `self.functions`: Diccionario para funciones definidas por el usuario y funciones nativas (`mostrar`, `ingresar`, `longitud`, `tipo_de`, funciones de conversi√≥n).
        *   `self.classes`: Diccionario para clases Zisk definidas por el usuario (mapeadas a clases Python generadas din√°micamente).
        *   `self.modules`: Diccionario para m√≥dulos Zisk importados üìÅ.
        *   `self.current_self`: Almacena la referencia a `este` cuando se ejecuta un m√©todo de instancia.
        *   `self.is_in_loop`, `self.is_in_function`: Contadores para validar `break`/`continue`/`retorna`.
*   **Funciones Nativas (`_native_...`)**: Implementaciones Python para las funciones incorporadas de Zisk.
*   **Gesti√≥n de √Åmbito (Runtime)**: `enter_scope()`, `exit_scope()`, `_get_current_scope()`.
*   **Operaciones de Variables (Runtime)**:
    *   `_declare_variable()`: A√±ade una variable al √°mbito actual, verificando si es constante y validando el tipo con `ZiskTypeSystem`.
    *   `_assign_variable()`: Modifica el valor de una variable existente, verificando si es constante y validando el tipo.
    *   `_get_variable_value()`: Busca y devuelve el valor de una variable, funci√≥n, clase o m√≥dulo.
    *   `_get_lvalue_location()`: Ayuda a determinar d√≥nde se debe asignar un valor (variable, atributo de objeto, elemento de lista).
*   **`execute(self, ast_node)`**:
    *   Este es el **int√©rprete del AST** ‚öôÔ∏èüå≥. Recorre el √°rbol nodo por nodo.
    *   Para cada tipo de nodo (`PROGRAMA`, `BLOQUE`, `DECLARACION_VAR`, `FUNCION`, `CLASE`, `SI`, `MIENTRAS`, `ASIGNACION`, `OPERACION_ARITMETICA`, `LLAMADA`, `IDENTIFICADOR`, etc.):
        *   Ejecuta la l√≥gica correspondiente.
        *   **Declaraciones**:
            *   `DECLARACION_VAR`/`CONST`: Eval√∫a el valor (si hay) y lo declara en el √°mbito actual.
            *   `FUNCION`: Crea una funci√≥n Python wrapper que, al ser llamada, establece un nuevo √°mbito, vincula argumentos, ejecuta el cuerpo de la funci√≥n Zisk y maneja `ReturnException`. Registra esta funci√≥n en `self.functions`.
            *   `CLASE`: Crea din√°micamente una clase Python. Los m√©todos Zisk se convierten en m√©todos Python (wrappers similares a los de funci√≥n). Los campos de instancia se inicializan en un `__init__` generado. Las constantes y campos est√°ticos se vuelven atributos de la clase Python. Registra la clase en `self.classes`.
            *   `IMPORTA`: Carga y ejecuta un archivo `.zk` üìÑ en una nueva instancia de `ZiskREPL` (para aislamiento) y lo hace accesible en el REPL actual.
        *   **Sentencias de Control**:
            *   `SI`: Eval√∫a la condici√≥n y ejecuta el bloque correspondiente.
            *   `MIENTRAS`/`PARA`/`HACER_MIENTRAS`: Ejecutan sus cuerpos iterativamente, manejando `BreakException` y `ContinueException`. `PARA` gestiona su propio √°mbito para la variable de inicializaci√≥n.
            *   `RETORNA`/`BREAK`/`CONTINUA`: Lanzan sus respectivas excepciones para alterar el flujo de control.
            *   `TRY_CATCH`: Ejecuta el bloque `try`. Si ocurre una excepci√≥n Zisk (o Python), y hay un bloque `catch` compatible, ejecuta el `catch`. El bloque `finally` se ejecuta siempre.
        *   **Expresiones**:
            *   `ASIGNACION`: Eval√∫a el lado derecho, determina la ubicaci√≥n del lado izquierdo y realiza la asignaci√≥n, incluyendo operaciones compuestas (`+=`, `-=`).
            *   Operaciones (aritm√©ticas, l√≥gicas, comparaci√≥n, unarias): Eval√∫an operandos y realizan la operaci√≥n, con chequeos de tipo b√°sicos en runtime y manejo de cortocircuito para `&&` y `||`.
            *   `LLAMADA`/`LLAMADA_NATIVA`: Eval√∫a el "llamable" (funci√≥n/m√©todo) y los argumentos, realiza la llamada y devuelve el resultado. Valida tipos de argumentos y retorno si la funci√≥n/m√©todo Zisk tiene metadatos.
            *   `CONSTRUCTOR` (`nuevo Clase(...)`): Busca la clase Python, eval√∫a argumentos y crea una instancia.
            *   `ACCESO_MIEMBRO` (`obj.miembro`): Eval√∫a el objeto y devuelve el atributo o m√©todo.
            *   `ACCESO_INDICE` (`col[indice]`): Eval√∫a la colecci√≥n y el √≠ndice, y devuelve el elemento. Soporta listas, diccionarios y cadenas.
            *   Literales (`NUMERO`, `CADENA`, `BOOLEANO`, `NULO`, `LISTA_LITERAL`, `OBJETO_LITERAL`): Devuelven su valor Python correspondiente.
            *   `IDENTIFICADOR`: Busca el valor en los √°mbitos.
            *   `ESTE`: Devuelve el valor de `self.current_self`.
*   **`evaluate(self, code: str, optimize: bool = True)`**: Orquesta el proceso: `lex.tokenize -> parser.parse -> optimizer.optimize (opc) -> compiler.compile (info) -> self.execute`.
*   **`run_repl(self)`**: Inicia el bucle interactivo üîÑ. Maneja entrada multil√≠nea, comandos especiales y errores.
*   **`handle_repl_command(self, comando_linea: str)`**: Procesa comandos como `:salir`, `:ayuda`, `:cargar`, `:vars`, etc.
*   **`load_and_execute_file(self, filepath: str, ...)`**: Carga un archivo `.zk` üìÑ, lo ejecuta y opcionalmente guarda el c√≥digo Python compilado.
*   **`show_repl_vars/funcs/clases/modules()`**: Comandos para inspeccionar el estado del REPL üìä.

## üìä 3. Flujo de Ejecuci√≥n T√≠pico (en el REPL)

1.  üßë‚Äçüíª Usuario introduce c√≥digo Zisk.
2.  `ZiskREPL.run_repl()` captura la entrada.
3.  Llama a `ZiskREPL.evaluate(codigo)`:
    a.  `ZiskLexer.tokenize(codigo)` -> `tokens` üîç
    b.  `ZiskParser.parse(tokens)` -> `ast_original` üå≥
    c.  (Si `optimize` es `True`) `ZiskOptimizer.optimize(ast_original)` -> `ast_optimizado` ‚ú®
    d.  (Para informaci√≥n o guardado) `ZiskCompiler.compile(ast_optimizado)` -> `codigo_python_compilado` üìúüêç
    e.  `ZiskREPL.execute(ast_optimizado)` -> `resultado_ejecucion` ‚ñ∂Ô∏è
        *   El m√©todo `execute` recorre el AST, interactuando con `self.scopes`, `self.functions`, `self.classes`, `ZiskTypeSystem` y lanzando/manejando excepciones de control de flujo.
4.  `ZiskREPL.run_repl()` imprime `resultado_ejecucion` (si no es `None`) üìÑ.
5.  El ciclo se repite üîÑ.

## üí° 4. Uso

### ‚å®Ô∏è 4.1. Ejecutar el REPL

```bash
python nombre_del_archivo.py
